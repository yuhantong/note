### **什么是HTTP ？**  
HTTP是应用层上的一个通信协议，HTTP2.0及之前的版本都是基于TCP实现，这也意味着HTTP协议具有TCP特性，包括面向连接，拥塞控制，流量控制等。但是，HTTP协议是一种无状态协议，无状态的意思就是客户端发起的每一个HTTP连接请求，完成一系列操作之后，连接都会断开（注意这里是连接请求，不是数据请求，之所以讲的是连接是因为在HTTP/1.0与HTTP/1.1有所区别，这里后面会讲到），而且不会记录这个连接状态。也就是说，下次客户端发起一个连接请求的时候，服务端会把这个连接当成是全新的连接。

### **HTTP的持续连接和非持续连接**   

HTTP/1.0中，如果客户端需要获取一个对象都需要建立一个连接，服务端返回之后，这个连接会立刻断开。如果需要在获取对象，这个时候又需要重新建立一个连接请求。这个情况就是非持续连接。

还有一种情况就是，客户端只要建立一个连接就可以获取通过多个请求获取多组数据对象，这个叫做持续连接。HTTP/1.1默认就是使用了这种连接方式。

非持续连接会导致服务端维护大量的连接，而且对于服务端来说，需要对每一个连接预留缓冲区和维持各种变量，这会造成巨大的服务器开销。除此之外，由于HTTP是基于TCP协议实现的，所以每发起一个连接都需要进行一次三次握手的过程，这个也会消耗网络资源。

持续连接则是客户端和服务端只需要维护一个连接。当客户端建立连接完成之后，服务端会为这个连接保持开启状态，客户端就可以复用这个连接请求数据。连接什么时候关闭有以下情况：  
1、客户端请求超时，服务端自动关闭。  
2、服务端数据返回成功且客户端成功接收，至于怎么知道客户端接收成功，在包头里面会告诉客户端这个包体大小。  
3、传输文件的时候，客户端是不知道什么时候完成的。这个也是有服务端来通知客户端数据已经传输完成，并且主动断开这个连接。  

持续连接对比非持续的优势：只需要一条连接就可以获取不同的资源对象，服务端也只要维护一组缓冲区和变量，这个有效的释放了服务端的资源眼里。同时减少的频繁的建立连接请求，这个可以让服务器响应客户端请求更加迅速，节省时间。
   
   
### **HTTP协议格式** 
这是一个访问百度首页的请求：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea119cad07e54f86a7d58e7197623a49~tplv-k3u1fbpfcp-watermark.image) 


**第一行：** Get表示请求方法，然后是一个空格；/表示请求路径，然后紧接着一个空格；HTTP/1.1表示协议版本是1.1。  

**第二行：** Host表示请求的域名。  

**第三行：** Connection表示请求返回之后连接需要继续保持。  

**第四行：** Cache-Control表示缓存的机制。指定 no-cache 或 max-age=0 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。  

**第五行：** Upgrade-Insecure-Request表示用来向服务器端发送信号，表示客户端优先选择加密及带有身份验证的响应，并且它可以成功处理upgrade-insecure-requests CSP 指令。简而言之就是，客户端支持服务端的升级机制，服务器可以重定这个站点的安全版本。在响应中可以添加一个 Vary 首部，这样的话，响应就不会被缓存服务器提供给不支持升级机制的客户端了。  
             
**第六行：** User-Agent表示网络协议的对端来识别发起请求的用户代理软件的应用类型、操作系统、软件开发商以及版本号。  

**第七行：** Accept表示客户端可以处理的内容类型。 

**第八行：** Accept-Encoding表示客户端可以接收的编码。  

**第九行：** Aeccept-Language表示支持的语言。  

**第十行：** Cookie表示服务端对客户端的一个标识。这个选项可以禁用。

**第十一行：** dnt(Do Not Track) 表明了用户对于网站追踪的偏好。它允许用户指定自己是否更注重个人隐私还是定制化内容。  

> 0  
> 表示用户愿意目标站点追踪用户个人信息。  
> 1  
> 表示用户不愿意目标站点追踪用户个人信息。 
                
**第十二行：** sec-gpc表示用户不希望共享偏好。 
    
      
      
以下是对应的回复：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/311238075ef14041b117522bd030d921~tplv-k3u1fbpfcp-watermark.image)   


**第一行:**  HTTP/1.1表示协议版本 200是状态码 OK表示这个请求回复正常。  
其他字段跟请求的含义是一样的，只不过是一问一答的形式而已。虽然一个HTTP请求会有很多字段，具体的字段意思可以参考这里。同时，一个HTTP协议的格式大概可以概述为：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac95602bf29f4fd29433e82a391f5c0f~tplv-k3u1fbpfcp-watermark.image)
 
 一些常用的请求方法:
 
![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3f51e6cbf9a4a62b6b458a63d8708fc~tplv-k3u1fbpfcp-watermark.image)

需要注意的是POST和GET请求的区别: GET请求通常是从获取数据，参数通常会拼接在请求头中，所以会有长度的限制。POST提交表单，会导致服务端数据发生改变，数据一般放在body中。当然，POST请求也是可以完成GET请求做的事。
这里是一些关于两个请求的讨论:
https://www.w3schools.com/tags/ref_httpmethods.asp  
https://stackoverflow.com/questions/504947/when-should-i-use-get-or-post-method-whats-the-difference-between-them?noredirect=1&lq=1

一些常用的回复字段

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3428c491415643cdbc7dc50f67a84877~tplv-k3u1fbpfcp-watermark.image)



## **HTTP1.0, HTTP1.1和HTTP2.0都有什么区别**

### **短连接模型：**

在1.0版本中，一个HTTP请求只能由一个连接建立。浏览器每发起一个请求都需要建立一个新的连接，并且需要在收到应答之后需要关闭这个连接。由于HTTP/1.0是基于TCP协议实现，每发起一个连接就相当于与重新建立一个TCP连接。由于TCP连接相当耗资源，客户端和服务端都要经过繁杂的握手之后才可以正式传送数据。如果网络堵塞或者带宽小的情况下，HTTP性能也会大打折扣。

### **长连接模型：**

长连接模型允许浏览器在一个连接中发起多个请求。在HTTP/1.1的头部中，会有一个Keep-Alive字段来指定这个连接的的声明周期。服务器会根据这个字段指定的时间来断开这个连接。HTTP/1.1 默认使用了长连接。HTPP/1.0如果需要启用长连接需要通常需要把Connection设置成close以外的值。

长连接模型缺陷：即使多个请求可以复用连接，但是这个连接在空闲状态下还是会消耗服务器资源。而且长连接模型也没法避免Dos攻击。该模型虽然可以实现并发，但是是通过创建多个连接实现的。在HTTP/1.x中浏览器需要在一个请求发挥之后才能发起另一个请求。

值得注意的是，在HTTP/1.X中，浏览器会同时为每个域名建立 6 条连接，但是这样的话可能会出现跨域问题。

### **HTTP2.0的改进**

HTTP2引入了全新的二进制分层，在不改变HTTP/1.x的应用语义下，通过修改数据在客户端和服务器间的传输方式（分帧），从而大大提高了性能的提升。HTTP2在数据传送时对请求头进行了压缩，而且可以复用一个连接传送数据帧，从而实现真正意义上的并发。此外，HTTP2支持请求优先级、流控制以及服务器推送等功能。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b9aaef02cd746c4957e7ad8cc50e7d3~tplv-k3u1fbpfcp-watermark.image)

通过对比HTTP2与HTTP/1.x可以知道，HTTP/1.x是通过换行符来做为文本的分隔符，HTTP2则是通过将数据分割成更小的消息和帧，并且采用二进制进行编码。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/026166557e2242b6b9a7fa0e2cb6f107~tplv-k3u1fbpfcp-watermark.image)

上图是一个HTTP2连接中，流，消息和帧的映射关系。这里需要先了解三个概念。  
	• stream:数据流，已经建立的连接内的双向字节流，可以承载一条或多条消息。  
	• message：消息。同一个流的一系列请求帧或者响应帧映射而成。  
	• frame: 帧。HTTP2通信的最小单位，每个帧包含帧头，至少也会标识当前帧所属的数据流。  

这些概念的关系总结如下：  
	• 所有通信都在一个TCP连接上完成，此连接可以承载任意数量的双向数据流。  
	• 每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。  
	• 每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。  
	• 帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。  
        
        
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf2437af2dca45eeab82563269cd2483~tplv-k3u1fbpfcp-watermark.image)
	
上图是HTTP2在一个连接中传输数据的过程，我们可以看到在一个TCP连接里。客户端和服务端可以相互独立，交错的传输数据流。同时这个也要求另一端在接收到这些帧数据后，通过一定的规则重组成一条消息。

HTTP2存在的问题:  
	• 虽然HTTP2解决了HTTP/1.x队列头部阻塞问题，但是还是受TCP层面的队列头部阻塞。  
	• 如果TCP的窗口缩放禁用，那么带宽延迟会限制连接的吞吐量。  
	• 出现丢包现象时，TCP拥塞窗口会被减小，这个也会给整个连接的吞吐量带来潜在的影响。  

### **HTTP错误码：**

	• 1xx消息
由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。   

**100 Continue**

服务器已经接收到请求头，并且客户端继续发送请求体。服务器必须在请求完成后向客户端发送一个最终响应。如果需要服务器检查请求的头部，客户端
必须在其初始化请求中发送Expect: 100-continue作为头部，并在发送正文之前接收100 continue状态码。
       
**101 Switching Protocols**   
    
服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。
在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。

	•   2xx成功
**200 ok**  
请求已成功，请求所希望的响应头或数据提将随此响应返回。

**204 Not Content**  
服务器成功处理了请求，没有返回任何内容。

	• 3xx重定向
**300 Multiple Choice**  
被请求的资源有一列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。  
    
**320 Found**  
要求客户端执行临时重定向，该重定向是临时的。
    
**304 Not Modified**   
表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后，未曾被修改。在这种情况下，由于客户端仍然具有以前下载的副本，因此资源不需要下载。

**305 Use Proxy**  
被请求的资源必须通过指定代理才能被访问。

	• 4xx客户端错误
**400 Bad Request**  
客户端错误，比如语法格式错误，请求体太大，请求无效导致服务器无法处理这个请求。

**401 Unauthorized**   
用户没有必要的凭证。

**403 Forbidden**  
服务器已经理解了请求，但是拒绝执行它。


**404 Not Found**  
请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。

**408 Request Timeout**  
请求超时。客户端如果没有服务器预备的等待时间内完成一个请求发送，客户端可以随时可以在此提交这一请求而无需任何更改。

	• 5xx 服务器错误
表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能服务器意识到当前的软硬件资源无法完成对应的请求处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误码以及这个状况是临时的还是永久的解释信息实体。

**500 Internal Server Error**  
通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成本次请求的处理。

**501 Not Implemented**  
服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。（例如，网络服务API的新功能）

**503 Service Unavailable**  
由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且在一段时间以后恢复。

**502 Bad Gateway**  
网关无法从上游服务器获取有效的响应。

**505 HTTP Version Not Supported**  
服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示服务器不能提供与当前客户端HTTP版本相同的响应。响应体中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。



**参考文章：**
    
https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn  
https://developer.mozilla.org/zhCN/docs/Web/HTTP/Connection_management_in_HTTP_1.x  
https://hpbn.co/http2/  
https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn    

**文章如有不严谨或错误的地方，欢迎指出，不胜感激。**
