### 易失存储介质和非易失存储介质

数据库的数据都是非易失性的（non-volatile），所以需要存储在磁盘上。由DBMS's组件管理数据在磁盘和内存之间的交换。  
在存储介质中，cpu寄存器，cpu缓存，cpu缓存，DRAM等都属于易失性。SSD，HDD，网络存储介质等属于非易失性。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa8eea3bd0524d80ad911bb4bbca6329~tplv-k3u1fbpfcp-watermark.image?)

在上图的存储层次中，读取速度: cpu寄存器 > cpu缓存 > DRAM > SSD>HDD > Network Storage

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a55c8a20fad74c53934e9ea663880f7e~tplv-k3u1fbpfcp-watermark.image?) 

如果将读取相同的数据在不同的存储介质上读取的时间是不一样的。将读取的时间等价与秒来计算，最块的读取速度需要0.5s，而最慢则需要31.7年。  

在上述所提及的存储介质中，CPU寄存器和CPU缓存是在CPU中实现的。DRAM就是我们平时说的内存。磁盘则包括：SSD，HDD，网络存储介质等。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20a51096fdc844d1893f553ed932d7fa~tplv-k3u1fbpfcp-watermark.image?)

### 顺序和随机访问
顺序访问指的是，连续的请求处于相同的磁道或是相邻的磁道上连续的块。在顺序访问中，第一块可能需要一次磁盘寻道，但是相继的请求既不需要寻道，也不需要对相邻磁道寻道。   
随机访问指的是，相继的请求会请求那些随机位于磁盘上的块。每个请求都需要一次磁盘寻道。  
对于访问同一数据源，顺序访问的速度会快于随机访问速度。  

对于DBMS来说，需要最大化的使用顺序访问的性能。在存储数据需要做到：  
1、通过算法尽量的量数据存储在一个连续的块中。  
2、对数据进行分页管理。   

此外，数据库的数据可能很大，所以读取数据的时候可能会出现读出来的数据远远大于内存大小，不可能一次性将数据全部加载到内存中。一个优秀的DBMS就要允许能够读取远大于内存大小的数据。  

此外，DBMS读取数据的时候，并不是根据条目进行读取的，而是根据数据页读取的。例如，现在需要读取某一条数据，DBMS并不是直接从磁盘读出这条数据，而是先从文件中确定这条数据在哪一个页，然后加载在缓存中。
DBMS都会设计一个缓存池，缓存池会存放从磁盘加载出来的数据。


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b628e5b1a71740188057c128ea8de68a~tplv-k3u1fbpfcp-watermark.image?)

### 为什么不用os
DBMS可以通过内存映射（mmap）方式将文件数据存储到程序的内存空间，并且将数据交给操作系统去管理。那为什么不直接让操作系统去管理这些数据呢？  

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5f265c455644969b51c7b09e4ef7eeb~tplv-k3u1fbpfcp-watermark.image?)

假设我们的物理内存只能存储两个页的信息。考虑这么一个场景，一个SQL查询需要扫表查询。这个时候操作系统将page1，page2放入内存中， 然后是page3，这似乎没问题。 

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e416971e65c14b90a7bc8cde83b22995~tplv-k3u1fbpfcp-watermark.image?)

这个时候另一个查询过来了，也是需要扫表查询，也是按照上述流程，依次将page1，page2，page3加入到内存中。

这里，我们仔细分析就会发现，第一次全表扫的时候，一些数据已经加载到内存中。但是因为我们将数据交给了操作系统进行管理，操作系统会将内存的数据随时替换，导致我们第二次读取数据的时候有重新将数据从磁盘中加载出来。  

所以，我们需要DBMS能够自主的管理数据库数据，并且满足以下要求：  
1、按照正确的顺序将脏页刷到磁盘。  
2、可以预读数据。  
3、优秀的缓存策略。   
4、可以自主控制线程/进程调度。  

### 文件组织 
一个数据库会被映射到不同的文件，这些文件会永久地存放在磁盘上。一个文件在逻辑上组织成为记录的一个序列。这些记录映射到磁盘块上。  
每个文件分成定长的存储单元，称为块（也叫页）。块是存储分配和数据传输的基本单元。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30265a132c5b44259cc608e314d1c93e~tplv-k3u1fbpfcp-watermark.image?)

值得注意的是，在每个文件中，起始位置会有一个文件头，图中的（directory）,文件头中包含了很多的信息，比如：  

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86347576b025413fad3281d33ddff538~tplv-k3u1fbpfcp-watermark.image?)

紧接着是一个一个块紧密的相连着。 在每个块中，会记录很多条记录，具体的记录条数是由每条记录的大小和块的大小决定的。在数据库中，一般不允许一条记录跨块存储，因为这样会增大查询数据的复杂度。  

假定有以下的数据表:
```sql
create table employee (
    id varchar(5);
    name varchar(20);
    dept_name varchar(20);
    salary numeric(8,2);
)
```
首先考虑第一种假设：每个字符站一个字节，numeric(8,2)占8个字节。每个字段都存储最大长度的信息，而不是分配可变长度。按照这么计算的话，一条记录的大小就是53个字节。  
现在我们需要考虑的问题有两个：  
* 除非块的大小刚好是53的倍数，否则会存在一些数据会跨块的可能性。当出现跨块的情况时候，读取这条数据就会出现两次磁盘访问才能完整拿到这个数据。  
* 删除一条记录的时候，所删除的记录必须由其他未被删除的记录进行填充。  
   
 解决第一个问题，在一个块中分配这个块能完整容纳下的最大记录数。块中最大可存储记录数可以通过块大小除以记录大小计算出来，然后舍弃小数部分。对于每个块中剩余的字节就直接舍弃不用。  
 解决第二问题，可以通过已经删除的记录记录下来，然后通过指针将这些记录连接成一条链表。    
 那么如何记录这个链表的起始地址呢？在前面有提及到，每个文件会有一个文件头记录一些信息，这个时候我们就可以把这个链表的起始地址记录在这里。当插入一条记录时，直接通过这个文件头所指向的记录，然后将文件头的指针指向记录的下一个地址。如果没有可用地址，那么直接在文件的末尾插入这条记录就行。  
 对于定长记录来说，插入和删除其实很容易实现，因为插入的记录和删除的记录所占用的空间时一致的。但是在实际中，数据会存在不定长的记录。如果对于不定长的记录也采用定长记录的方式，那么则会浪费很多磁盘空间。  
 
在数据库中变长记录会有以下方式出现：  
* 多种记录类型存在一个文件中。
* 允许一个或多个字段是变长的记录类型。
* 允许可重复字段的记录类型，例如数组或多重集合。 

在这种情况下，我们必须要解决以下两个问题：  
* 如何描述一条记录，是单个属性可以轻松抽取。  
* 在块中如何存储变长记录，使得块中的记录可以轻松的抽取。  

一条变长属性的记录通常具有两个部分：初始部分是定长属性，接下来是变长属性。对于定长属性，如数字值、日期或定长字符串，分配存储它们的值锁需要的字节数。对于变长属性，如varchar类型，在记录的初始部分中表示为一个对（偏移量，长度）值，其中偏移量表示在记录中该属性的数据开始位置，长度表示变长属性的字节长度。这些变长属性紧跟在定长属性之后，并且是连续排序。
  
现在假设第二种情况，数据在上述表中存的是变长记录,。
 
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0ce8c9b4ed9460b827333bf9b1c6309~tplv-k3u1fbpfcp-watermark.image?)
在上图中，表示的是一条变长数据在文件中的记录，假设这条记录在磁盘中的地址为X，偏移量和长度存储在两个字节中。在0-11字节中记录了三个变长属性的信息。其中，id字段从21字节处开始，占用了5个字节，读取id属性需要从X偏移5个字节。name字段，从26字节开始，占用了10个字节，读取name字段偏移10个字段。dept_name字段类似。salary字段记录在12-19字节处。  
在之后使用1个字节记录了该记录中的属性是否是空值（NULL）。因为这个表中只有四个字段，所以使用一个字节足够了，对于更多字段的记录该字段大小可能会不一样。在该记录中，如果salary的值为空，那么第四为将会是1，这时候读取这条数据会跳过12-19的地址读取。当然，有些数据库会将空值做一些特殊处理，这个不同数据库实现不一样，但是大体的结构与思想都是一样的。  

现在我们需要解决如何存储变长记录的问题。存储变长记录使用的是分槽的页结构。如图：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2021ea204ad94756a1a7668cb1968bac~tplv-k3u1fbpfcp-watermark.image?)

每个块中有一个块头，包含以下信息:  
* 块头中记录条目的个数。  
* 块中空闲地址的末尾出。  
* 一个由包含记录位置和大小的记录条目组成的数组。 


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/426614a1808640e9a1ddf32ed21574ba~tplv-k3u1fbpfcp-watermark.image?)

在记录数据的时候，是从块的尾部开始连续排列的。块中空闲空间时连续的，在块头数组的最后一个条目和第一条记录之间。插入数据的时候就从空闲空间的末尾分配空间，并且将包含这条记录大小和位置添加到块头中。  
如果一条记录被删除，所占用的空间将会被释放，并且条目会被设置成删除状态。此外，块中在被删除记录之前的记录将被移动，使得由删除而产生的空间空间被重用。同时移动块头指向空闲空间末尾的指针。在这种结构下，只要块中有空间就可以使记录增长或缩短。而且移动记录的代价并不高，因为每个块大小都是有限制（4~8KB，MySQL 16KB）。  
上述的存储结构要求没有指针直接指向记录。取而代之，指针必须指向块头中记有记录实际位置的条目。在支持指向记录的间接指针的同时，这种间接层次允许移动记录以防止在块的内部出现碎片空间。  

此外，对于一些大文件存储，比如数据大于一个块。这时候数据库并不会存在这个块中，而是存储在其它文件中，然后记录对应的位置地址。  

### 总结  

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4df33b326b8c439ca69237083c0dd481~tplv-k3u1fbpfcp-watermark.image?)

















